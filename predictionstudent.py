# -*- coding: utf-8 -*-
"""predictionStudent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jQ15VDVeyVP5cXzq4nNClVcJhqKzPw8P

**This is the first evaluating task for a Big Data subject in a Data science Master program.
student's name : Diana Carolina Salazar Velandia
Group : MIBT-23-6A**
"""

pip install pyspark

pip install findspark

from google.colab import drive
drive.mount('/content/drive')

from pyspark.sql import SparkSession
from pyspark.ml.feature import VectorAssembler
from pyspark.ml.regression import LinearRegression
from pyspark.ml.evaluation import RegressionEvaluator

data_path = "/content/drive/MyDrive/Colab Notebooks/Student_Performance.csv"

session = SparkSession.builder.appName("SparkML_regression").getOrCreate()

data = session.read.csv(data_path, header=True, inferSchema=True)

data.printSchema()

data.show(10)

"""**Convert 'Extracurricular Activities' variable type from string in to int (1 and 0)**"""

from pyspark.sql import SparkSession
from pyspark.sql.functions import when
prueba = data.withColumn('Extracurricular Activities', when(data['Extracurricular Activities'] == "Yes", 1).otherwise(0))

prueba.show()

"""we can find the correlation between our independent variables vs the variable "Performance Index" to make an idea wich of them is more correlated. In this case the highest correlation index is with the variable "Previous Scores", so the linear regretion with this variable should present a minor error"""

corr_rate = []
for i in prueba.columns :
  compa = data_transformed.stat.corr(i, 'Performance Index')
  corr_rate.append(compa)

corr_rate

##this is a code for find the correlation between all variables#Este for halla la correlacion entre cada columna las columnas#
#corr_rate = []
#vals = ['Hours Studied','Previous Scores', 'Extracurricular Activities', 'Sleep Hours', 'Sample Question Papers Practiced', 'Performance Index']
#for i in prueba.columns :
#  for j in vals:
#    compa = data_transformed.stat.corr(i, j)
#    corr_rate.append(compa)

#corr_rate

"""this code find the correlation matrix between all variables, but in this case we have to ignore information about variable "Extracurricular Activities" cause it is not a continous variable."""

import pandas as pd
prueba_pd = prueba.toPandas()
corr_matrix = prueba_pd.corr()
corr_matrix.to_xarray
print(corr_matrix)

import matplotlib.pyplot as plt # To make graphics//graficas

"""We made some graphics in order to visualize the variable's behavior"""

plt.scatter(prueba_pd['Previous Scores'], prueba_pd['Performance Index'],
            marker="*", s=15, color="green",
            label="Previous Score vs Performance Index" )
plt.scatter(prueba_pd['Extracurricular Activities'], prueba_pd['Performance Index'],
            marker="*", s=15, color="red",
            label="'Extracurricular Activities'vsPI" )
plt.scatter(prueba_pd['Hours Studied'], prueba_pd['Performance Index'],
            marker="*", s=15, color="cyan",
            label="'Hours Studied'vsPI" )
plt.scatter(prueba_pd['Sleep Hours'], prueba_pd['Performance Index'],
            marker="*", s=15, color="blue",
            label="'Sleep HoursvsPI" )
plt.scatter(prueba_pd['Sample Question Papers Practiced'], prueba_pd['Performance Index'],
            marker="*", s=5, color="magenta",
            label="'Sample Question Papers Practiced'vsPI" )


plt.ylabel("Performance Index")
plt.xlabel("independent variables")
plt.legend(bbox_to_anchor=(1, 0.2))
plt.show()

"""With this graphics we saw a strong linearity behavior between variables "Previous Score vs Performance Index" as was suggested by the correlation index

There the code create the colum features taking acount all posible variables
"""

assembler = VectorAssembler(inputCols=['Hours Studied','Previous Scores', 'Extracurricular Activities', 'Sleep Hours', 'Sample Question Papers Practiced'], outputCol="features")
fulldata_transformed = assembler.transform(prueba)

fulldata_transformed.show()

"""Here the code apply the linear model and calcule the errors of prediction"""

(training_data, testing_data) = fulldata_transformed.randomSplit([0.7, 0.3], seed=23)
lr = LinearRegression(featuresCol="features", labelCol="Performance Index")
model = lr.fit(training_data)
predictions = model.transform(testing_data)
predictions.show(20)
evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="rmse")
rmse = evaluator.evaluate(predictions)
print("RMSE =", rmse)
evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="mae")
mae = evaluator.evaluate(predictions)
print("MAE =", mae)

"""here the code apply the linear model and find the error but just between the variable "Previous Scores" and "Performance Index" cause that variables has the highest correlation index. Later, we will see if in fact it is the variable that produces the least possible error."""

assembler = VectorAssembler(inputCols=['Previous Scores'], outputCol="features")
PSdata_transformed = assembler.transform(prueba)

(training_data, testing_data) = PSdata_transformed.randomSplit([0.7, 0.3], seed=23)
lr = LinearRegression(featuresCol="features", labelCol="Performance Index")
model = lr.fit(training_data)
predictions = model.transform(testing_data)
predictions.show(20)
evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="rmse")
rmse = evaluator.evaluate(predictions)
print("RMSE =", rmse)
evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="mae")
mae = evaluator.evaluate(predictions)
print("MAE =", mae)

"""Now we gonna check the error of linear prediction with ALL posible combinations of variables. **Firstable we gonna apply the linear model to each of variables one by one vs variable "Performance Index"**

This "for" create a new data frame each time with a diferent column "features" depending on the variable in list "vals5"
"""

vals5 = ['Hours Studied','Previous Scores', 'Extracurricular Activities', 'Sleep Hours', 'Sample Question Papers Practiced']

features1by1 = []
for i in vals5:
  assembler = VectorAssembler(inputCols=[i], outputCol="features")
  data_transformed1by1 = assembler.transform(prueba)
  print(i)
  #data_transformed1by1.show()
  features1by1.append(data_transformed1by1)

"""this for develop a linear model per each of 5 variables vs variable "Performance Index"
"""

errorsrmse1 =[]
errorsmae1 =[]
for j in features1by1:
  (training_data, testing_data) = j.randomSplit([0.7, 0.3], seed=23)
  lr = LinearRegression(featuresCol="features", labelCol="Performance Index")
  model = lr.fit(training_data)
  predictions = model.transform(testing_data)
 # predictions.show(20)
  evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="rmse")
  rmse = evaluator.evaluate(predictions)
  print("RMSE =", rmse)
  evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="mae")
  mae = evaluator.evaluate(predictions)
  print("MAE =", mae)
  errorsrmse1.append(rmse)
  errorsmae1.append(mae)
print("Errors RMSE", errorsrmse1)
print("Errors RMSE", errorsmae1)

"""As we can see, on effect, the variable "Previous Scores" with a highes correlation index, gives us the linear prediction model with a smallest error.

In order to find excactly the best combination possible, the next code find the all possible combinations of two variables and keep it in a list that we will use as a input for a column features and to apply a linear regression model.
"""

from itertools import combinations
vals5 = ['Hours Studied','Previous Scores', 'Extracurricular Activities', 'Sleep Hours', 'Sample Question Papers Practiced']
combinaciones2 = list(combinations(vals5,2))
print(combinaciones2)

"""this code creates the column features as a vector, using two variables acording with the list "combinaciones2" vs "performance index"
"""

features2by2 = []
for i in combinaciones2:
  assembler = VectorAssembler(inputCols=i, outputCol="features")
  data_transformed2by2 = assembler.transform(prueba)
  print(i)
 # data_transformed1by1.show()
  features2by2.append(data_transformed2by2)

"""this code applies the linear regression model to all possible combinations of two variables and show us the errors. In this case the smallest error is obtained by combining the variables "('Hours Studied', 'Previous Scores')"
"""

errorsrmse2 =[]
errorsmae2 = []
for j in features2by2:
  (training_data, testing_data) = j.randomSplit([0.7, 0.3], seed=23)
  lr = LinearRegression(featuresCol="features", labelCol="Performance Index")
  model = lr.fit(training_data)
  predictions = model.transform(testing_data)
 # predictions.show(20)
  evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="rmse")
  rmse = evaluator.evaluate(predictions)
  print("RMSE =", rmse)
  evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="mae")
  mae = evaluator.evaluate(predictions)
  print("MAE =", mae)
  errorsrmse2.append(rmse)
  errorsmae2.append(mae)

print("Errors RMSE", errorsrmse2)
print("Errors RMSE", errorsmae2)

"""Now we will find the all possible combinations with tree variables"""

from itertools import combinations
vals5 = ['Hours Studied','Previous Scores', 'Extracurricular Activities', 'Sleep Hours', 'Sample Question Papers Practiced']
combinaciones3 = list(combinations(vals5,3))
print(combinaciones3)

"""this code creates the column features as a vector, using three variables acording with the list "combinaciones3" vs "performance index"
"""

features3by3 = []
for i in combinaciones3:
  assembler = VectorAssembler(inputCols=i, outputCol="features")
  data_transformed3by3 = assembler.transform(prueba)
  print(i)
 # data_transformed1by1.show()
  features3by3.append(data_transformed3by3)

"""this code applies the linear regression model to all possible combinations of two variables and show us the errors. In this case the smallest error is obtained by combining the variables "('Hours Studied', 'Previous Scores', 'Sleep Hours')"
"""

errorsrmse3 =[]
errorsmae3 = []
for j in features3by3:
  (training_data, testing_data) = j.randomSplit([0.7, 0.3], seed=23)
  lr = LinearRegression(featuresCol="features", labelCol="Performance Index")
  model = lr.fit(training_data)
  predictions = model.transform(testing_data)
 # predictions.show(20)
  evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="rmse")
  rmse = evaluator.evaluate(predictions)
  print("RMSE =", rmse)
  evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="mae")
  mae = evaluator.evaluate(predictions)
  print("MAE =", mae)
  errorsrmse3.append(rmse)
  errorsmae3.append(mae)

print("Errors RMSE", errorsrmse3)
print("Errors RMSE", errorsmae3)

"""Now we will find the all possible combinations with four variables"""

from itertools import combinations
vals5 = ['Hours Studied','Previous Scores', 'Extracurricular Activities', 'Sleep Hours', 'Sample Question Papers Practiced']
combinaciones4 = list(combinations(vals5,4))
print(combinaciones4)

"""this code creates the column features as a vector, using three variables acording with the list "combinaciones4" vs "performance index"
"""

features4by4 = []
for i in combinaciones4:
  assembler = VectorAssembler(inputCols=i, outputCol="features")
  data_transformed4by4 = assembler.transform(prueba)
  print(i)
 # data_transformed1by1.show()
  features4by4.append(data_transformed4by4)

"""this code applies the linear regression model to all possible combinations of two variables and show us the errors. In this case the smallest error is obtained by combining the variables "('Hours Studied', 'Previous Scores', 'Sleep Hours', 'Sample Question Papers Practiced')"
"""

errorsrmse4 =[]
errorsmae4 = []
for j in features4by4:
  (training_data, testing_data) = j.randomSplit([0.7, 0.3], seed=23)
  lr = LinearRegression(featuresCol="features", labelCol="Performance Index")
  model = lr.fit(training_data)
  predictions = model.transform(testing_data)
 # predictions.show(20)
  evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="rmse")
  rmse = evaluator.evaluate(predictions)
  print("RMSE =", rmse)
  evaluator = RegressionEvaluator(labelCol="Performance Index", predictionCol="prediction", metricName="mae")
  mae = evaluator.evaluate(predictions)
  print("MAE =", mae)
  errorsrmse4.append(rmse)
  errorsmae4.append(mae)

print("Errors RMSE", errorsrmse4)
print("Errors RMSE", errorsmae4)